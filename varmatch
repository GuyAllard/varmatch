#!/usr/bin/env python

import sys

RUN = True

author_email = 'chensun@cse.psu.edu'
versionError = 'You are using an old version of python, please upgrade to python 2.7+\n'

if sys.hexversion < 0x02070000:
    print (versionError)
    exit()

import subprocess
import argparse
import os

citation = 'Please cite our paper'

parser = argparse.ArgumentParser(epilog = citation)
parser.add_argument('-r', metavar='reference.vcf', help='reference vcf file path')
parser.add_argument('-q', metavar='query.vcf', help='query vcf file path')
parser.add_argument('-g', metavar='genome.fa', help='genome sequence file path, FASTA file format')
parser.add_argument('-t', metavar='N', default='1', help='thread number for parallel')
parser.add_argument('-n', '--no_normalize', action='store_true', help='if activate, program will not normalize reference vcf and query vcf file before comparing.')
parser.add_argument('-d', '--direct_search', action='store_true', help='if activate, only perform direct matching')
parser.add_argument('--multi_genome', metavar='genome_list.txt', help='genome list file contain chromosome name and FASTA file absolute path')
parser.add_argument('--multi_vcf', nargs='+', metavar='file.vcf ...', help='vcf files (usually more than two) that need to compare')
parser.add_argument('-o', '--output', metavar='output/', help='output directory, default is the current directory')
parser.add_argument('-v', '--visualize', help='visualize results')
parser.add_argument('--no_purify', action='store_true', help='if activate, program will not check if variant matches reference genome sequence.')
parser.add_argument('--remove_dup', metavar='single.vcf', help='provide single vcf file, remove duplications in this vcf file')
# strategy for whole genome:
#   since current version of vt-normalize can not handle whole genome sequence data
#   vcfcompare split whole genome data according to chromosome detected in --whole-genome directory
args = parser.parse_args()

def shell_run(command, hide=False):
    if not RUN:
        time.sleep(3.5)
        print(command)
    else:
        #print(command)
        if hide: # hide output
            FNULL = open(os.devnull, 'w')
            subprocess.call(command, shell=True, stdout=FNULL, stderr=subprocess.STDOUT)
            #subprocess.call(command, shell=True, stdout=FNULL)
            FNULL.close()
        else:
            subprocess.call(command, shell=True)

def check_command(command): 
    """
    check if corresponding command available
    """
    if os.path.isfile(command):
        return True

    for cmdpath in os.environ['PATH'].split(':'):
        if os.path.isdir(cmdpath) and command in os.listdir(cmdpath):
            return True
    return False

# [todo] check vcf files, corresponding genome file should exist

# purify vcf file
def purify(input_file, output_file, genome_file):
    global check_purify_command
    if not check_purify_command and not check_command(purify_tool):
        print ('Error: can not find program: '+ purify_tool)
        print ('\t Try "make" command before execute, or contact author for support: ' + author_email)
        exit()
    else:
        check_purify_command = True
    purify_command = purify_tool + ' -i ' + input_file + ' -g ' + genome_file + ' -o ' + output_file
    shell_run(purify_command)

def normalize(input_file, output_file, genome_file):
    global check_normalize_command
    global normalize_tool
    # check if vt normalize exist
    if not check_normalize_command and not check_command(vt_tool):
        if check_command('vt normalize'):
            normalize_tool = 'vt normalize'
            check_normalize_command = True
        else:
            print ('Error: can not find program: '+ normalize_tool)
            print ('\t Try "make" command before execute, or contact author for support: ' + author_email)
            exit()
    else:
        check_normalize_command = True

    normalize_command = normalize_tool + ' ' + input_file + ' -r ' + genome_file + ' -o ' + output_file
    shell_run(normalize_command, True)

def pairwise_compare(reference_file, query_file, genome_file, output_prefix):
    global check_compare_command
    if not check_compare_command and not check_command(compare_tool):
        print ('Error: can not find program: '+ compare_tool)
        print ('\t Try "make" command before execute, or contact author for support: ' + author_email)
        exit()
    else:
        check_compare_command = True
    compare_command = compare_tool + ' -r ' + reference_file + ' -q ' + query_file + ' -g ' + genome_file + ' -o ' + output_prefix

    if args.t is not None and int(args.t) > 1:
        compare_command += ' -t ' + args.t
    shell_run(compare_command)

def varmatch_pairwise(reference_file, query_file, genome_file, output_directory):
    ref_basename = os.path.basename(reference_file)
    que_basename = os.path.basename(query_file)

    ref_purify_file = temp_dir + '/' + ref_basename + '.purify.vcf'
    que_purify_file = temp_dir + '/' + que_basename + '.purify.vcf'
    if not args.no_purify:
        purify(reference_file, ref_purify_file, genome_file)
        purify(query_file, que_purify_file, genome_file)
    else:
        ref_purify_file = reference_file
        que_purify_file = query_file

    ref_purify_norm_file = temp_dir + '/' + ref_basename + '.norm.vcf'
    que_purify_norm_file = temp_dir + '/' + que_basename + '.norm.vcf'
    if not args.no_normalize:
        normalize(ref_purify_file, ref_purify_norm_file, genome_file)
        normalize(que_purify_file, que_purify_norm_file, genome_file)
    else:
        ref_purify_norm_file = ref_purify_file
        que_purify_norm_file = que_purify_file

    output_prefix = output_directory + '/' + ref_basename + '_' + que_basename

    pairwise_compare(ref_purify_norm_file, que_purify_norm_file, genome_file, output_prefix)

    return output_prefix
    

def detect_multi_genome(genome_list_file, chr_list):
    genome_dict = {}
    with open(genome_list_file) as f:
        for line in f.readlines():
            line = line.strip()
            columns = line.split()
            chr_name = columns[0]
            if chr_name in chr_list:
                genome_dict[chr_name] = columns[1]
    return genome_dict

def split_multi_genome(vcf_file, detected_chr_list):
    print ('Split variant file according to chromosomes...')
    vcf_name_dict = {}
    basename = os.path.basename(vcf_file)
    for c in detected_chr_list:
        vcf_name_dict[c] = temp_dir + '/' + basename + '.' + c + '.vcf'

    vcf_handle_dict = {}
    for c in detected_chr_list:
        vcf_handle_dict[c] = open(vcf_name_dict[c], 'w')

    with open(vcf_file) as f:
        for line in f.readlines():
            if line.startswith('#'):
                for c in detected_chr_list:
                    vcf_handle_dict[c].write(line)
                continue
            for c in detected_chr_list:
                chromosome_name = line.split('\t')[0]
                if chromosome_name == c or chromosome_name == 'chr'+c:
                    vcf_handle_dict[c].write(line)
                    break

    for c in detected_chr_list:
        vcf_handle_dict[c].close()
    return vcf_name_dict

def varmatch_multi_genome(reference_file, query_file, genome_list_file):
    #split vcf according to chromosome and then use varmatch_pairwise
    human_chromosome_list = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','X','Y']
    genome_dict = detect_multi_genome(genome_list_file, human_chromosome_list)
    detected_chr_list = list(genome_dict.keys())
    detected_chr_list.sort()
    print ('\t[Multiple genome mode]')
    print ('\tDetected genomes:')
    chr_list_string = '\t'
    #print (chr_list_string, detected_chr_list)
    for c in detected_chr_list:
        chr_list_string += c+','
    chr_list_string = chr_list_string[:-1] + '\n'
    print (chr_list_string)
    for c in detected_chr_list:
        if not os.path.isfile(genome_dict[c]):
            print ('[Error:] Can not find genome file ' + genome_dict[c])
            exit()


    ref_vcf_dict = split_multi_genome(reference_file, detected_chr_list)
    que_vcf_dict = split_multi_genome(query_file, detected_chr_list)

    for c in detected_chr_list:
        print('Matching chromosome ' + c + '...')
        varmatch_pairwise(ref_vcf_dict[c], que_vcf_dict[c], genome_dict[c], temp_dir)

    #[todo] summarize running results
    chr_stat_dict = {}
    total_stat = []
    if args.direct_search:
        total_stat = [0,0,0,0,0,0]
    else:
        total_stat = [0,0,0,0,0,0,0,0]
    for c in detected_chr_list:
        stat_file = temp_dir + '/' + os.path.basename(ref_vcf_dict[c]) + '_' + os.path.basename(que_vcf_dict[c]) + '.stat'
        chr_stat_dict[c] = stat_file
        with open(stat_file) as f:
            lines = f.readlines()
            for i in range(len(total_stat)):
                total_stat[i] += int(lines[i].strip())

    total_stat_filename = output_dir + '/' + os.path.basename(reference_file) + '_' + os.path.basename(query_file) + '.stat'
    with open(total_stat_filename, 'w') as f:
        for s in total_stat:
            f.write(str(s))
            f.write('\n')




    
def varmatch_multi_vcf_single_genome(id_vcf_dict, genome_file, output_prefix):
    
    """
    id_vcf_dict key: id, value: vcf file
    """

    id_finalname_dict = {}
    finalname_id_dict = {}
    id_list = list(id_finalname_dict.keys())
    id_list.sort()

    for id in id_list:
        vcf_file = id_vcf_dict[id]
        if not os.path.isfile(vcf_file):
            print('Error: Can not open vcf file '+vcf_file)
        vcf_file_id = id
        basename = os.path.basename(vcf_file)

        purify_file = temp_dir + '/' + basename + '.purify.vcf'
        if not args.no_purify:
            purify(vcf_file, purify_file, genome_file)
        else:
            purify_file = vcf_file

        purify_norm_file = temp_dir + '/' + basename + '.norm.vcf'
        if not args.no_normalize:
            normalize(purify_file, purify_norm_file, genome_file)
        else:
            purify_norm_file = purify_file
        id_finalname[vcf_file_id] = purify_norm_file

    pairwise_prefix_idtuple = {}
    idtuple_pairwise_prefix = {}
    for i in range(len(id_list)-1):
        ref_id = id_list[i]
        que_id = id_list[i+1]
        id_tuple = (ref_id, que_id)
        ref_filename = id_finalname_dict[ref_id]
        que_filename = id_finalname_dict[que_id]
        
        pairwise_prefix = varmatch_pairwise(ref_filename, que_filename, genome_file, temp_dir)
        pairwise_prefix_idtuple[pairwise_prefix] = id_tuple
        idtuple_pairwise_prefix[id_tuple] = pairwise_prefix

    # summarize
    # [todo] summarize simple matches
    # summarize complex matches
    # [todo] summarize matching number
    # variantid = position + ref.toupper + alt.toupper
    variantid_variant = {}
    variantid_info = {}
    for i in range(len(id_list) - 1):
        ref_id = id_list[i]
        que_id = id_list[i+1]
        id_tuple = (ref_id, que_id)
        pairwise_prefix = idtuple_pairwise_prefix[id_tuple]
        complex_match_file = pairwise_prefix+'.complex'
        if not os.path.isfile(complex_match_file):
            print('Error: Can not open complex match result ' + complex_match_file)
        with open(complex_match_file) as f:
            for line in f.readlines():
                if line.startswith('#'):
                    continue
                line = line.strip()
                columns = line.split('\t')
                variantid = '@'.join(columns[1:4])
                if i == 0:
                    variantid_variant[variantid] = columns[:4]
                    variantid_info[variantid] = columns[4:]
                else:
                    if variantid in variantid_info:
                        variantid_info[variantid].append(columns[-1])
    
    integrate_complex_filename = output_prefix+'.complex'
    integrate_complex_file = open(integrate_complex_filename)
    for i in range(len(id_list)):
        head_line = '##VCF'+str(i+1)+':'+id_vcf_dict[id]+'\n'
        integrate_complex_file.write(head_line)

    head_line = '#CHR\tPOS\tREF\tALT'
    for i in range(len(id_list)):
        head_line += '\tVCF'+str(i+1)
    integrate_complex_file.write(head_line)
    
    common_complex_num = 0
    for variantid in sort(variantid_info):
        if variantid_info[variantid].size() == id_list.size():
            common_complex_num += 1
            merge_list = variantid_variant[variantid] + variantid_info[variantid]
            variant_line = '\t'.join(variant)
            integrate_complex_file.write(variant_line)
    integrate_complex_file.close()

    print(common_complex_num)


def main():
   
    if len(sys.argv) < 2:
        parser.print_help()
        exit()

    #initialize global variables
    global check_purify_command
    global check_normalize_command
    global check_compare_command

    global script_path
    global purify_tool
    global normalize_tool
    global vt_tool
    global compare_tool
    global output_dir
    global visual_dir
    global temp_dir
    
    check_purify_command = False
    check_normalize_command = False
    check_compare_command = True

    script_path = sys.path[0]
    purify_tool = script_path + '/purify'
    vt_tool = script_path + '/vt/vt'
    normalize_tool = script_path + '/vt/vt normalize'
    compare_tool = script_path + '/src/vm'
    output_dir = ''
    visual_dir = ''
    temp_dir = ''
    
    # create output directory
    if args.output is None or args.output == '':
        output_dir = os.getcwd() + '/output'
    else:
        output_dir = args.output
    if output_dir == '':
        output_dir = os.getcwd() + '/output'
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    temp_dir = output_dir + '/temp'
    visual_dir = output_dir + '/visualization'

    if not os.path.exists(temp_dir):
        os.mkdir(temp_dir)
    
    #print args.r, args.q

    if args.multi_genome is not None and args.multi_genome != '':
        if args.multi_vcf is not None:
            # multi genome, multi vcf
            pass
        elif args.remove_dup is not None:
            # multi genome, single vcf(remove duplicates)
            pass
        else:
            # pure multi genome, to compare two genome
            varmatch_multi_genome(args.r, args.q, args.multi_genome)
    elif args.multi_vcf is not None:
        # multi vcf, single chromosome
        output_prefix = output_dir + '/common'
        varmatch_multi_vcf_single_genome(args.multi_vcf, args.g, output_prefix)
    else:
        # single chromosome, pairwise compare 
        varmatch_pairwise(args.r, args.q, args.g, output_dir)

if __name__ == '__main__':
    main()


